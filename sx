#!/bin/bash

API_KEY="${OSINT_SX_API_KEY}"

if [ -z "$API_KEY" ]; then
  echo "Error: OSINT_SX_API_KEY environment variable not set" >&2
  exit 1
fi

# Check for yq availability - will use fallback parsing if not available
YQ_AVAILABLE=false
if command -v yq &>/dev/null && yq --version >/dev/null 2>&1; then
  YQ_AVAILABLE=true
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="$HOME/.config/sx"
SERVICES_FILE="$CONFIG_DIR/services.yaml"

extract_modules() {
  local file="$1"
  if [ "$YQ_AVAILABLE" = true ]; then
    {
      yq eval '.email_modules[]' "$file" 2>/dev/null | sed 's/email$//'
      yq eval '.phone_modules[]' "$file" 2>/dev/null | sed 's/phone$//'
      yq eval '.username_modules[]' "$file" 2>/dev/null | sed 's/username$//'
    }
  else
    # Fallback parsing without yq
    {
      sed -n '/^email_modules:/,/^[a-z_]*_modules:/{/^  - /s/^  - //p}' "$file" | sed 's/email$//'
      sed -n '/^phone_modules:/,/^[a-z_]*_modules:/{/^  - /s/^  - //p}' "$file" | sed 's/phone$//'
      sed -n '/^username_modules:/,/^$/{/^  - /s/^  - //p}' "$file" | sed 's/username$//'
    }
  fi
}

sync_services() {
  echo -n "Syncing services... "
  
  mkdir -p "$CONFIG_DIR"
  
  local temp_file="/tmp/sx_services_$$"
  local old_modules_file="/tmp/sx_old_modules_$$"
  local new_modules_file="/tmp/sx_new_modules_$$"
  local has_existing=false
  
  if [ -f "$SERVICES_FILE" ]; then
    has_existing=true
    cp "$SERVICES_FILE" "${SERVICES_FILE}.backup"
    extract_modules "$SERVICES_FILE" | sort > "$old_modules_file"
  fi
  
  if curl -sf "https://raw.githubusercontent.com/gnomegl/sx/HEAD/services.yaml" -o "$temp_file" 2>/dev/null; then
    if [ "$has_existing" = true ]; then
      extract_modules "$temp_file" | sort > "$new_modules_file"
      
      mv "$temp_file" "$SERVICES_FILE"
      
      local added_services=$(comm -13 "$old_modules_file" "$new_modules_file" | grep -v '^$')
      local removed_services=$(comm -23 "$old_modules_file" "$new_modules_file" | grep -v '^$')
      
      if [ -n "$added_services" ] || [ -n "$removed_services" ]; then
        echo "done"
        if [ -n "$added_services" ]; then
          local added_count=$(echo "$added_services" | wc -l)
          echo "$added_count new service$([ $added_count -ne 1 ] && echo "s") added:"
          echo "$added_services" | while read -r service; do
            local service_name=$(echo "$service" | sed 's/.*/\u&/' | sed 's/\([a-z]\)\([A-Z]\)/\1 \2/g')
            echo "  • $service_name"
          done
        fi
        if [ -n "$removed_services" ]; then
          local removed_count=$(echo "$removed_services" | wc -l)
          echo "$removed_count service$([ $removed_count -ne 1 ] && echo "s") removed:"
          echo "$removed_services" | while read -r service; do
            local service_name=$(echo "$service" | sed 's/.*/\u&/' | sed 's/\([a-z]\)\([A-Z]\)/\1 \2/g')
            echo "  • $service_name"
          done
        fi
      else
        echo "done"
      fi
    else
      mv "$temp_file" "$SERVICES_FILE"
      echo "done"
      local total_services=$(extract_modules "$SERVICES_FILE" | wc -l)
      echo "$total_services services downloaded"
    fi
  else
    echo "failed"
    rm -f "$temp_file"
    if [ "$has_existing" = true ]; then
      echo "Using cached services file"
    elif [ -f "$SCRIPT_DIR/services.yaml" ]; then
      echo "Using local services file"
      if cp "$SCRIPT_DIR/services.yaml" "$SERVICES_FILE" 2>/dev/null; then
        local total_services=$(extract_modules "$SERVICES_FILE" | wc -l)
        echo "$total_services services loaded"
      else
        echo "Error: Failed to copy local services.yaml file" >&2
        exit 1
      fi
    else
      echo "Error: Could not download services.yaml and no local fallback exists" >&2
      echo "Expected local file at: $SCRIPT_DIR/services.yaml" >&2
      exit 1
    fi
  fi
  
  # Cleanup temp files
  rm -f "$old_modules_file" "$new_modules_file"
}

sync_services

if [ ! -f "$SERVICES_FILE" ]; then
  echo "Error: services.yaml not found at $SERVICES_FILE" >&2
  exit 1
fi

JSON_MODE=false

show_usage() {
  echo "Usage: sx [OPTIONS] <email|phone|username> <identifier>"
  echo ""
  echo "Options:"
  echo "  -j, --json    Output raw JSON stream (no formatting)"
  echo "  -l, --list    List all available modules"
  echo "  -h, --help    Show this help message"
  echo ""
  echo "Examples:"
  echo "  sx email user@domain.com"
  echo "  sx username johndoe"
  echo "  sx phone +15551234567"
  echo "  sx --json email user@domain.com"
  echo "  sx --list email"
}

get_modules_by_type() {
  local module_type="$1"
  local file="$2"
  if [ "$YQ_AVAILABLE" = true ]; then
    yq eval ".${module_type}_modules[]" "$file" 2>/dev/null
  else
    sed -n "/^${module_type}_modules:/,/^[a-z_]*_modules:/{/^  - /s/^  - //p}" "$file"
  fi
}

list_modules() {
  local module_type="$1"
  case "$module_type" in
  email)
    echo "Available Email Modules:"
    get_modules_by_type "email" "$SERVICES_FILE" | while read -r module; do
      local service_name=$(echo "$module" | sed 's/email$//')
      local service_info=$(get_service_info "$service_name")
      local icon=$(echo "$service_info" | cut -d'|' -f1)
      local name=$(echo "$service_info" | cut -d'|' -f2)
      echo "  $icon $name ($module)"
    done
    ;;
  phone)
    echo "Available Phone Modules:"
    get_modules_by_type "phone" "$SERVICES_FILE" | while read -r module; do
      local service_name=$(echo "$module" | sed 's/phone$//')
      local service_info=$(get_service_info "$service_name")
      local icon=$(echo "$service_info" | cut -d'|' -f1)
      local name=$(echo "$service_info" | cut -d'|' -f2)
      echo "  $icon $name ($module)"
    done
    ;;
  username)
    echo "Available Username Modules:"
    get_modules_by_type "username" "$SERVICES_FILE" | while read -r module; do
      local service_name=$(echo "$module" | sed 's/username$//')
      local service_info=$(get_service_info "$service_name")
      local icon=$(echo "$service_info" | cut -d'|' -f1)
      local name=$(echo "$service_info" | cut -d'|' -f2)
      echo "  $icon $name ($module)"
    done
    ;;
  *)
    echo "Available module types: email, phone, username"
    echo "Usage: sx --list <type>"
    ;;
  esac
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
    -j | --json)
      JSON_MODE=true
      shift
      ;;
    -l | --list)
      if [ -n "$2" ] && [[ ! "$2" =~ ^- ]]; then
        list_modules "$2"
        exit 0
      else
        echo "Error: Module type required for --list" >&2
        echo "Usage: sx --list <email|phone|username>" >&2
        exit 1
      fi
      ;;
    -h | --help)
      show_usage
      exit 0
      ;;
    -*)
      echo "Unknown option: $1" >&2
      show_usage
      exit 1
      ;;
    *)
      if [ -z "$MODULE_TYPE" ]; then
        MODULE_TYPE="$1"
      elif [ -z "$IDENTIFIER" ]; then
        IDENTIFIER="$1"
      else
        echo "Too many arguments" >&2
        show_usage
        exit 1
      fi
      shift
      ;;
    esac
  done
}

format_json_value() {
  local value="$1"
  local indent="$2"
  local key="$3"

  local type=$(echo "$value" | jq -r 'type')

  case "$type" in
  "object")
    if [ -n "$key" ]; then
      echo -e "${indent}\033[1;32m${key}:\033[0m"
    fi
    local keys=$(echo "$value" | jq -r 'keys[]' 2>/dev/null)
    if [ -n "$keys" ]; then
      while IFS= read -r k; do
        local v=$(echo "$value" | jq -c --arg key "$k" '.[$key]')
        format_json_value "$v" "${indent}  " "$k"
      done <<<"$keys"
    fi
    ;;
  "array")
    if [ -n "$key" ]; then
      echo -e "${indent}\033[1;32m${key}:\033[0m"
    fi
    local count=$(echo "$value" | jq 'length')
    if [ "$count" -eq 0 ]; then
      echo "${indent}  (empty)"
    else
      local i=0
      while [ $i -lt $count ]; do
        local item=$(echo "$value" | jq -c ".[$i]")
        if echo "$item" | jq -e 'type == "string" or type == "number" or type == "boolean"' >/dev/null 2>&1; then
          echo "${indent}  • $(echo "$item" | jq -r '.')"
        else
          format_json_value "$item" "${indent}  " ""
        fi
        ((i++))
      done
    fi
    ;;
  "string" | "number" | "boolean")
    local val=$(echo "$value" | jq -r '.')
    if [ -n "$key" ]; then
      echo -e "${indent}\033[1;32m${key}:\033[0m $val"
    else
      echo "${indent}$val"
    fi
    ;;
  "null")
    if [ -n "$key" ]; then
      echo -e "${indent}\033[1;32m${key}:\033[0m null"
    fi
    ;;
  esac
}

get_service_info() {
  local class_name="$1"
  local service_name=""
  local icon=""

  local base_name=$(echo "$class_name" | sed 's/email$//' | sed 's/phone$//' | sed 's/username$//' | sed 's/register$//' | sed 's/.*/\L&/')

  if [ "$YQ_AVAILABLE" = true ]; then
    local service_data=$(yq eval ".categories.*.services.$base_name" "$SERVICES_FILE" 2>/dev/null | head -1)
    if [ -n "$service_data" ] && [ "$service_data" != "null" ]; then
      icon=$(echo "$service_data" | yq eval '.icon' - 2>/dev/null)
      service_name=$(echo "$service_data" | yq eval '.name' - 2>/dev/null)
    fi
  else
    # Fallback parsing for service info
    local service_line=$(grep -A 1000 "services:" "$SERVICES_FILE" | grep "^      $base_name:" | head -1)
    if [ -n "$service_line" ]; then
      icon=$(echo "$service_line" | sed -n 's/.*icon: *"\([^"]*\)".*/\1/p')
      service_name=$(echo "$service_line" | sed -n 's/.*name: *"\([^"]*\)".*/\1/p')
    fi
  fi

  if [ -z "$service_name" ]; then
    service_name=$(echo "$base_name" | sed 's/.*/\u&/')
    icon="❓"
  fi

  echo "$icon|$service_name"
}

format_result() {
  local class_name="$1"
  local result="$2"

  local service_info=$(get_service_info "$class_name")
  local icon=$(echo "$service_info" | cut -d'|' -f1)
  local service_name=$(echo "$service_info" | cut -d'|' -f2)

  if [[ "$class_name" == *"breach"* ]]; then
    echo -e "\n\033[1;31m${icon} ${service_name}\033[0m"
    if echo "$result" | jq -e '.full.breaches' >/dev/null 2>&1; then
      local breach_count=$(echo "$result" | jq '.full.breaches | length' 2>/dev/null || echo "0")
      if [ "$breach_count" -gt 0 ]; then
        echo "  Found in $breach_count data breaches"
      else
        echo "  No breaches found"
      fi
    else
      echo "  No breach information available"
    fi
    return
  fi

  echo -e "\n\033[1;36m${icon} ${service_name}\033[0m"

  if echo "$result" | jq -e '. == null or . == {}' >/dev/null 2>&1; then
    echo "  No data available"
    return
  fi

  format_json_value "$result" "  " ""
}

if [ $# -eq 0 ]; then
  show_usage
  exit 1
fi

parse_args "$@"

if [ -z "$MODULE_TYPE" ] || [ -z "$IDENTIFIER" ]; then
  echo "Error: Both module type and identifier required" >&2
  show_usage
  exit 1
fi

if [ "$JSON_MODE" = true ]; then
  curl -X POST https://api.osint.sx/search \
    -H "x-api-key: $API_KEY" \
    -H "content-type: application/json" \
    -d "{\"moduleType\": \"$MODULE_TYPE\", \"identifier\": \"$IDENTIFIER\"}" \
    -s | jq -c 'select(.progress == null)'
else
  echo -e "\033[1;36m🔍 OSINT Search Results for: $IDENTIFIER\033[0m"
  echo -e "\033[1;90m$(date '+%Y-%m-%d %H:%M:%S')\033[0m"

  temp_file="/tmp/sx_registered_$$"
  module_buffer="/tmp/sx_module_$$"

  curl -X POST https://api.osint.sx/search \
    -H "x-api-key: $API_KEY" \
    -H "content-type: application/json" \
    -d "{\"moduleType\": \"$MODULE_TYPE\", \"identifier\": \"$IDENTIFIER\"}" \
    -s | while IFS= read -r line; do
    if echo "$line" | jq -e '.className and .result' >/dev/null 2>&1; then
      class_name=$(echo "$line" | jq -r '.className')
      result=$(echo "$line" | jq -c '.result')

      if [[ "$class_name" == *"register"* ]]; then
        service_name=$(echo "$class_name" | sed 's/emailregister$//' | sed 's/phoneregister$//' | sed 's/usernameregister$//' | sed 's/register$//')
        echo "$service_name" >>"$temp_file"
      else
        format_result "$class_name" "$result" >"$module_buffer"
        cat "$module_buffer"
        rm -f "$module_buffer"
      fi
    fi
  done

  if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
    echo -e "\n\033[1;33m📋 Registered Services\033[0m"
    while IFS= read -r service; do
      echo -e "  • \033[1;32m$(echo "$service" | sed 's/.*/\L&/' | sed 's/\b\w/\U&/g')\033[0m: Registered"
    done <"$temp_file"
    rm -f "$temp_file"
  fi
fi
